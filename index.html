<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestión de Horarios</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #3b82f6; /* Azul más profesional */
            --secondary-color: #10b981; /* Verde esmeralda */
            --danger-color: #ef4444; /* Rojo para alertas */
            --background-color: #f8fafc; /* Fondo muy claro */
            --surface-color: #ffffff; /* Color de las "tarjetas" */
            --text-color: #1f2937; /* Gris muy oscuro para el texto */
            --light-text-color: #6b7280; /* Gris claro para texto secundario */
            --border-color: #e5e7eb;
            --box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            --border-radius: 12px;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            line-height: 1.6;
        }

        h1, h2, h3 {
            color: var(--text-color);
            font-weight: 600;
        }

        /* Estilo del reloj en la esquina superior derecha */
        #current-time {
            font-size: 2.2em;
            font-weight: 500;
            color: var(--primary-color);
            text-align: right;
            margin-bottom: 20px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.05);
        }

        /* Estilo del contador de personas */
        #person-count {
            font-size: 1.1em;
            font-weight: 500;
            color: var(--light-text-color);
            margin-bottom: 15px;
        }

        .form-container, .modal-content, .table-container table {
            background-color: var(--surface-color);
            padding: 0;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }

        .form-container h2, h2, h3 {
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0;
            margin-bottom: 24px;
        }
        
        .form-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        /* Estilo para el encabezado colapsable */
        .collapsible-header {
            cursor: pointer;
            padding-bottom: 0;
            border-bottom: 1px solid var(--border-color);
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            margin-bottom: 0;
        }
        .collapsible-header:hover {
            color: var(--primary-color);
        }
        .collapsible-header::after {
            content: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="%236b7280" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18l6-6-6-6"/></svg>');
            display: block;
            width: 20px;
            height: 20px;
            transform: rotate(0deg);
            transition: transform 0.2s ease;
        }
        .collapsible-header.expanded::after {
            transform: rotate(90deg);
        }
        /* Contenido que se colapsa */
        .collapsible-content {
            display: none;
            padding-top: 0;
        }
        .collapsible-content.visible {
            display: block;
        }

        .form-container form {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 15px;
            align-items: end;
        }
        .form-container label {
            font-weight: 500;
            margin-bottom: 5px;
            display: block;
        }
        .form-container input {
            padding: 0;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            box-sizing: border-box;
            width: 100%;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        .form-container input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .form-container button {
            padding: 0;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
            font-weight: 500;
        }
        .form-container button.add-slot-btn,
        .form-container button.add-game-btn,
        .form-container button[type="submit"] {
            background-color: var(--primary-color);
        }
        .form-container button.add-slot-btn:hover,
        .form-container button.add-game-btn:hover,
        .form-container button[type="submit"]:hover {
            background-color: #2563eb;
            transform: translateY(-1px);
        }
        .form-container button.remove-slot-btn,
        .clear-data-btn,
        .delete-person-btn {
            background-color: var(--danger-color);
        }
        .form-container button.remove-slot-btn:hover,
        .clear-data-btn:hover,
        .delete-person-btn:hover {
            background-color: #dc2626;
            transform: translateY(-1px);
        }
        .alerts-btn {
            background-color: #f59e0b; /* Amarillo vibrante */
            color: white;
        }
        .alerts-btn:hover {
            background-color: #d97706;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        .button-group button {
            flex-grow: 1;
        }
        
        /* Estilos de la tabla */
        .table-container {
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            margin-top: 20px;
        }
        
        thead th, tbody td {
            padding: 0;
            text-align: center;
            border-bottom: 1px solid var(--border-color);
            border-right: 1px solid var(--border-color);
        }

        thead th:first-child,
        tbody td:first-child {
            border-top-left-radius: 12px;
            border-bottom-left-radius: 12px;
        }
        thead th:last-child,
        tbody td:last-child {
            border-top-right-radius: 12px;
            border-bottom-right-radius: 12px;
        }

        th {
            background-color: var(--primary-color);
            color: white;
            font-weight: 600;
            border-right: 1px solid #2563eb;
        }
        th:first-child {
            background-color: #1f2937;
        }

        /* Estilos para las columnas fijas */
        #schedule-header th:first-child,
        #schedule-header th:nth-child(2) {
            position: sticky;
            left: 0;
            z-index: 11;
        }
        #horario-body td:first-child,
        #horario-body td:nth-child(2) {
            position: sticky;
            left: 0;
            background-color: var(--surface-color);
            z-index: 10;
        }

        /* Ajustar el desplazamiento de las celdas fijas */
        #schedule-header th:first-child { left: 0; min-width: 150px; }
        #schedule-header th:nth-child(2) { left: 150px; }
        #horario-body td:first-child { left: 0; min-width: 150px; }
        #horario-body td:nth-child(2) { left: 150px; }

        tr:nth-child(even) td {
            background-color: #f9fafb;
        }
        tr:hover td {
            background-color: #eff6ff;
        }
        tr:hover td:first-child,
        tr:nth-child(even):hover td:first-child,
        tr:hover td:nth-child(2),
        tr:nth-child(even):hover td:nth-child(2) {
             background-color: #eff6ff;
        }

        /* Estilos de las celdas de tiempo */
        .card-time {
            background-color: var(--primary-color);
            color: white;
            padding: 0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s;
            cursor: grab;
            user-select: none;
            display: block;
        }
        .card-time:active {
            cursor: grabbing;
        }
        .card-time:hover {
            transform: translateY(-2px);
        }
        .time-input {
            width: 100%;
            padding: 0;
            text-align: center;
            border: none;
            background-color: transparent;
            color: white;
            font-weight: 500;
            font-size: 1em;
        }
        .time-input:focus {
            outline: 2px solid white;
        }

        /* Estilos del selector de mesas */
        .card-selector {
            display: flex;
            flex-direction: row; 
            flex-wrap: wrap;       
            gap: 0;
            align-items: center;
            justify-content: center;
        }
        .mesa-select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-color: var(--surface-color);
            padding: 0;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            text-align: center;
            font-size: 0.9em;
            font-weight: 500;
            cursor: pointer;
            width: 50%;
            transition: all 0.2s ease;
            color: var(--light-text-color);
            
            /* CÓDIGO ELIMINADO PARA QUITAR LA FLECHA */
            /*
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="%236b7280" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 9l6 6 6-6"/></svg>');
            background-repeat: no-repeat;
            background-position: right 8px center;
            */
            padding-right: 0;
        }
        .mesa-select:hover {
            border-color: var(--primary-color);
        }
        .mesa-select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }
        .mesa-select:not([value=""]) {
            color: var(--primary-color);
            font-weight: 600;
        }
        .mesa-select option {
            font-weight: 400;
            color: var(--text-color);
        }
        
        .clear-data-btn {
            background-color: var(--danger-color);
            color: white;
            padding: 0;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 20px;
        }
        .add-game-btn, .alerts-btn {
            padding: 0;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 10px;
            transition: background-color 0.3s ease;
            font-weight: 500;
        }
        
        /* Estilos del botón de alerta activo (parpadeo) */
        .alerts-btn.active {
            background-color: var(--danger-color);
            color: white;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.03); }
            100% { transform: scale(1); }
        }

        /* Estilos del Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
            padding-top: 60px;
        }
        .modal-content {
            background-color: var(--surface-color);
            margin: 5% auto;
            padding: 0;
            border: none;
            width: 90%;
            max-width: 500px;
            border-radius: var(--border-radius);
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
        }
        .close-btn {
            color: var(--light-text-color);
            float: right;
            font-size: 2.5em;
            font-weight: normal;
            line-height: 1;
            cursor: pointer;
            transition: color 0.2s ease;
        }
        .close-btn:hover, .close-btn:focus {
            color: var(--danger-color);
            text-decoration: none;
        }
        .modal-body label {
            display: block;
            margin-top: 20px;
            font-weight: 500;
        }
        .modal-body input[type="time"],
        .modal-body input[type="color"],
        .modal-body select {
            width: 100%;
            padding: 0;
            margin-top: 8px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            box-sizing: border-box;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        .modal-body .replace-section {
            margin-top: 25px;
            border-top: 1px solid var(--border-color);
            padding-top: 0;
        }
        .modal-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
            gap: 10px;
        }
        .modal-buttons button {
            width: 100%;
        }
        
        #replacePersonBtn {
            background-color: #f59e0b;
            color: white;
            font-weight: 600;
        }
        #replacePersonBtn:hover {
            background-color: #d97706;
        }
        .delete-person-btn {
            margin-top: 20px;
        }

        /* Estilos para las alertas */
        .person-name {
            cursor: grab;
            font-weight: 500;
            padding: 0;
            border-radius: 8px;
            transition: background-color 0.3s;
            display: block;
            color: var(--text-color);
            white-space: nowrap;
        }
        .person-name.text-white {
            color: white;
        }
        /* Estilos para la lista de alertas */
        #warning-list {
            list-style: none;
            padding-left: 0;
            margin: 0;
        }
        #warning-list li {
            font-weight: 500;
            margin-bottom: 8px;
            cursor: pointer;
            padding: 0;
            border-radius: 8px;
            background-color: #fffbeb; /* Fondo amarillo claro */
            border-left: 4px solid var(--danger-color);
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
        }
        #warning-list li::before {
            content: '⚠️';
            margin-right: 10px;
        }
        #warning-list li:hover {
            background-color: #fef3c7;
        }

        /* Estilos del pie de página (firma) */
        footer {
            margin-top: 50px;
            padding-top: 0;
            border-top: 1px solid var(--border-color);
            text-align: center;
        }
        #app-signature {
            font-size: 0.8em;
            color: var(--light-text-color);
        }
        
        /* Estilos para la lista de juegos personalizados */
        .game-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .game-list li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0;
            border-bottom: 1px solid var(--border-color);
        }
        .game-list li:last-child {
            border-bottom: none;
        }
        .game-list button {
            background-color: var(--danger-color);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 0;
            font-size: 0.9em;
            cursor: pointer;
        }
        
        /* Estilo para la fila arrastrada */
        .dragging {
            opacity: 0.6;
        }
        
        /* Estilo para la columna del tiempo en mesa */
        #schedule-header th:nth-child(2) {
            background-color: #374151; /* Un gris oscuro que combina bien */
            color: white;
            border-right: 1px solid #1f2937;
        }
        .time-in-table {
            background-color: #f3f4f6; /* Gris más claro */
            color: var(--text-color);
            font-weight: 600;
            transition: all 0.2s ease;
        }
        #horario-body tr:hover .time-in-table {
            background-color: #dbeafe; /* Azul claro para el hover */
        }
        
    </style>
</head>
<body>

    <div id="current-time"></div>
    

    <div class="form-container">
        <h2 id="registration-header" class="collapsible-header">Turnos</h2>
        <div id="registration-content" class="collapsible-content visible">
            <form id="person-form">
                <div>
                    <label for="nombre">Nombre:</label>
                    <input type="text" id="nombre" name="nombre" required>
                </div>
                <button type="submit">Agregar Persona</button>
            </form>
            <div class="button-group">
                <button id="add-game-btn" class="add-game-btn">Gestionar Juegos</button>
                <button id="alerts-btn" class="alerts-btn">Alertas</button>
                <button id="clear-data" class="clear-data-btn">Borrar todos los datos</button>
            </div>
        </div>
    </div>

    ---

    <div id="person-count"></div>
    <h2>Tabla de Turnos</h2>

    <div class="table-container">
        <table>
            <thead id="schedule-header">
                <tr>
                    <th>Nombres</th>
                    <th>Tiempo en mesa</th>
                </tr>
            </thead>
            <tbody id="horario-body">
                </tbody>
        </table>
    </div>

    <div id="personModal" class="modal">
        <div class="modal-content">
            <span id="closePersonModalBtn" class="close-btn">&times;</span>
            <h3 id="modalTitle">Configurar Persona</h3>
            <div class="modal-body">
                <label for="exitTime">Hora de Salida:</label>
                <input type="time" id="exitTime">

                <label for="personColor">Color de fondo:</label>
                <input type="color" id="personColor">
                
                <div class="modal-buttons">
                    <button id="savePersonBtn" class="add-slot-btn">Guardar</button>
                </div>
                
                <div class="replace-section">
                    <label for="replacesPersonSelect">Reemplazar a otra persona:</label>
                    <select id="replacesPersonSelect">
                        <option value="">Seleccionar persona...</option>
                    </select>
                    <button id="replacePersonBtn">Reemplazar</button>
                </div>
                <button id="deletePersonBtn" class="delete-person-btn">Eliminar</button>
            </div>
        </div>
    </div>
    
    <div id="addGameModal" class="modal">
        <div class="modal-content">
            <span id="closeAddGameModalBtn" class="close-btn">&times;</span>
            <h3>Gestionar Juegos</h3>
            <div class="modal-body">
                <form id="add-game-form">
                    <label for="new-game-name-input">Nombre del juego:</label>
                    <input type="text" id="new-game-name-input" placeholder="Ej: Ruleta" required>
                    <label>
                        <input type="checkbox" id="repeatable-checkbox"> Permitir repetición
                    </label>
                    <div class="modal-buttons">
                        <button type="submit" class="add-slot-btn">Agregar Juego</button>
                    </div>
                </form>
                <h4 style="margin-top: 20px;">Juegos Personalizados</h4>
                <ul id="custom-game-list" class="game-list">
                    </ul>
            </div>
        </div>
    </div>

    <div id="warningModal" class="modal">
        <div class="modal-content">
            <span id="closeWarningModalBtn" class="close-btn">&times;</span>
            <h3>Alertas de Salida</h3>
            <div class="modal-body">
                <p>Las siguientes personas tienen un horario de salida próximo (menos de 20 minutos):</p>
                <ul id="warning-list"></ul>
            </div>
        </div>
    </div>

    <footer>
        <p id="app-signature">CarlosPN Interactive®</p>
    </footer>

    <script>
        let scheduleData = [];
        let peopleData = [];
        let gameOptionsData = [];

        const DEFAULT_SLOT = { start: '08:00' };
        
        const STATIC_GAME_OPTIONS = [
            { value: 'DrP7', text: 'DrP7', repeatable: false },
            { value: 'DrP12', text: 'DrP12', repeatable: false },
            { value: 'HP8', text: 'HP8', repeatable: false },
            { value: 'CbP13', text: 'CbP13', repeatable: false },
            { value: 'Bj15', text: 'Bj15', repeatable: false },
            { value: 'Bj17', text: 'Bj17', repeatable: false },
            { value: 'Bj34', text: 'Bj34', repeatable: false },
            { value: 'RA21', text: 'RA21', repeatable: false },
            { value: 'RA24', text: 'RA24', repeatable: false },
            { value: 'RA25', text: 'RA25', repeatable: false },
            { value: 'RF22', text: 'RF22', repeatable: false },
            { value: 'RF23', text: 'RF23', repeatable: false },
            { value: 'Cr26', text: 'Craps26', repeatable: false },
            { value: 'Bs30', text: 'Bigsig30', repeatable: false },
            { value: 'PararFichas', text: 'Parar Fichas', repeatable: true },
            { value: 'Colacion', text: 'Colación', repeatable: true },
            { value: 'D.P.R', text: 'D.P.R', repeatable: true }
        ];

        const MESA_OPTIONS = [
            { value: 'Mesa1', text: 'Mesa 1' },
            { value: 'Mesa2', text: 'Mesa 2' },
            { value: 'Mesa3', text: 'Mesa 3' },
            { value: 'Mesa4', text: 'Mesa 4' },
            { value: 'Mesa5', text: 'Mesa 5' },
        ];

        let currentPersonIndex = -1;
        let alertIntervalId;
        let timerIntervalId;

        function getGameOptionsHtml() {
            return gameOptionsData.map(option => `<option value="${option.value}">${option.text}</option>`).join('');
        }
        
        function getMesaOptionsHtml() {
            return MESA_OPTIONS.map(option => `<option value="${option.value}">${option.text}</option>`).join('');
        }

        function getGameTextByValue(value) {
            const allOptions = [...STATIC_GAME_OPTIONS, ...gameOptionsData.filter(opt => !STATIC_GAME_OPTIONS.some(staticOpt => staticOpt.value === opt.value)), ...MESA_OPTIONS];
            const option = allOptions.find(opt => opt.value === value);
            return option ? option.text : '';
        }

        function isGameRepeatable(value) {
            const allOptions = [...STATIC_GAME_OPTIONS, ...gameOptionsData.filter(opt => !STATIC_GAME_OPTIONS.some(staticOpt => staticOpt.value === opt.value)), ...MESA_OPTIONS];
            const option = allOptions.find(opt => opt.value === value);
            return option ? option.repeatable : false;
        }

        function isDarkColor(hexColor) {
            const c = hexColor.substring(1);
            const rgb = parseInt(c, 16);
            const r = (rgb >> 16) & 0xff;
            const g = (rgb >> 8) & 0xff;
            const b = (rgb >> 0) & 0xff;
            const luma = 0.2126 * r + 0.7152 * g + 0.0722 * b;
            return luma < 128;
        }

        function saveData() {
            localStorage.setItem('appSchedule', JSON.stringify(scheduleData));
            localStorage.setItem('appPeople', JSON.stringify(peopleData));
            localStorage.setItem('appGameOptions', JSON.stringify(gameOptionsData));
        }

        function loadAllData() {
            const savedSchedule = localStorage.getItem('appSchedule');
            const savedPeople = localStorage.getItem('appPeople');
            const savedGameOptions = localStorage.getItem('appGameOptions');

            if (savedSchedule) {
                try {
                    scheduleData = JSON.parse(savedSchedule);
                } catch (e) {
                    console.error("Error al cargar los horarios, inicializando con valores por defecto.", e);
                    scheduleData = [DEFAULT_SLOT];
                }
            } else {
                scheduleData = [DEFAULT_SLOT];
            }

            if (savedPeople) {
                try {
                    peopleData = JSON.parse(savedPeople);
                    peopleData.forEach(person => {
                        if (!Array.isArray(person.games)) {
                            person.games = [];
                        }
                        person.games.forEach((gamesArray, index) => {
                            if (!Array.isArray(gamesArray)) {
                                person.games[index] = [gamesArray];
                            }
                        });
                        while (person.games.length < scheduleData.length) {
                             person.games.push([]);
                        }
                    });
                } catch (e) {
                    console.error("Error al cargar las personas, inicializando con un array vacío.", e);
                    peopleData = [];
                }
            } else {
                peopleData = [];
            }
            
            if (savedGameOptions) {
                try {
                    const customOptions = JSON.parse(savedGameOptions).filter(option => !STATIC_GAME_OPTIONS.some(staticOpt => staticOpt.value === option.value));
                    gameOptionsData = [...STATIC_GAME_OPTIONS, ...customOptions];
                } catch (e) {
                    console.error("Error al cargar las opciones de juego, inicializando con valores por defecto.", e);
                    gameOptionsData = STATIC_GAME_OPTIONS;
                }
            } else {
                gameOptionsData = STATIC_GAME_OPTIONS;
            }
            
            if (scheduleData.length === 0) {
                scheduleData = [DEFAULT_SLOT];
            }

            saveData();
            renderTable();

            clearInterval(alertIntervalId);
            clearInterval(timerIntervalId);
            alertIntervalId = setInterval(checkExitTimes, 10000);
            timerIntervalId = setInterval(updateTableTimers, 1000);
            setInterval(updateClock, 1000);
        }

        function renderTable() {
            renderSchedule();
            renderPeople();
            checkExitTimes();
        }

        function renderSchedule() {
            const headerRow = document.querySelector('#schedule-header tr');
            headerRow.innerHTML = `
                <th style="background-color: var(--text-color); color: white; border-top-left-radius: var(--border-radius); border-right: 1px solid #3c4043;">Nombres</th>
                <th style="background-color: var(--text-color); color: white; border-right: 1px solid #3c4043;">Tiempo en mesa</th>
            `;

            scheduleData.forEach((slot, index) => {
                const headerCell = document.createElement('th');
                headerCell.classList.add('draggable-slot');
                headerCell.draggable = true;
                headerCell.setAttribute('data-slot-index', index);

                headerCell.innerHTML = `
                    <div class="card-time">
                        <input type="time" class="time-input" value="${slot.start || ''}" data-slot-index="${index}">
                    </div>
                `;
                headerRow.appendChild(headerCell);
            });
            
            const controlCell = document.createElement('th');
            controlCell.style.backgroundColor = 'var(--primary-color)';
            controlCell.style.borderTopRightRadius = 'var(--border-radius)';
            controlCell.style.borderRight = 'none';
            controlCell.innerHTML = `
                <div class="button-group">
                    <button class="add-slot-btn" style="background-color: var(--secondary-color);">+</button>
                    <button class="remove-slot-btn" style="background-color: var(--danger-color);">-</button>
                </div>
            `;
            headerRow.appendChild(controlCell);

            const timeInputs = document.querySelectorAll('#schedule-header .time-input');
            timeInputs.forEach(input => {
                input.addEventListener('change', function() {
                    const index = parseInt(this.getAttribute('data-slot-index'));
                    scheduleData[index].start = this.value;
                    saveData();
                    renderPeople();
                });
            });

            const addBtn = document.querySelector('.add-slot-btn');
            if (addBtn) addBtn.addEventListener('click', addSlot);
            const removeBtn = document.querySelector('.remove-slot-btn');
            if (removeBtn) removeBtn.addEventListener('click', removeSlot);

            addDragAndDropEventListenersToSlots();
        }

        function renderPeople() {
            const tbody = document.getElementById('horario-body');
            tbody.innerHTML = '';
            peopleData.forEach((person, personIndex) => {
                const newRow = document.createElement('tr');
                newRow.draggable = true;
                newRow.setAttribute('data-person-index', personIndex);

                // Celda del nombre
                const nameCell = document.createElement('td');
                const nameSpan = document.createElement('span');
                nameSpan.classList.add('person-name');
                nameSpan.setAttribute('data-person-index', personIndex);
                nameSpan.textContent = person.name;

                if (person.color) {
                    nameCell.style.backgroundColor = person.color;
                    if (isDarkColor(person.color)) {
                        nameSpan.classList.add('text-white');
                    } else {
                        nameSpan.classList.remove('text-white');
                    }
                } else {
                    nameCell.style.backgroundColor = '';
                    nameSpan.classList.remove('text-white');
                }

                nameCell.appendChild(nameSpan);
                newRow.appendChild(nameCell);
                
                // Celda del tiempo en mesa
                const timeCell = document.createElement('td');
                timeCell.classList.add('time-in-table');
                timeCell.setAttribute('data-person-index', personIndex);
                newRow.appendChild(timeCell);
                
                scheduleData.forEach((slot, slotIndex) => {
                    const gameCell = document.createElement('td');
                    const cardSelector = document.createElement('div');
                    cardSelector.classList.add('card-selector');

                    const games = person.games[slotIndex] || [];
                    
                    games.forEach((game, gameIndex) => {
                        cardSelector.appendChild(createMesaSelector(personIndex, slotIndex, gameIndex, game));
                    });
                    
                    cardSelector.appendChild(createMesaSelector(personIndex, slotIndex, games.length, ''));
                    
                    gameCell.appendChild(cardSelector);
                    newRow.appendChild(gameCell);
                });
                
                const emptyCell = document.createElement('td');
                newRow.appendChild(emptyCell);

                tbody.appendChild(newRow);
                addNameClickListeners(newRow);
            });
            addDragAndDropEventListenersToPeople();
            updatePersonCount();
        }
        
        function createMesaSelector(personIndex, slotIndex, gameIndex, selectedValue = '') {
            const select = document.createElement('select');
            select.classList.add('mesa-select');
            select.setAttribute('data-person-index', personIndex);
            select.setAttribute('data-slot-index', slotIndex);
            select.setAttribute('data-game-index', gameIndex);
            
            const allOptions = [
                { value: '', text: '+' }, 
                ...gameOptionsData,
                ...MESA_OPTIONS
            ];

            const uniqueOptions = Array.from(new Set(allOptions.map(opt => JSON.stringify(opt)))).map(optStr => JSON.parse(optStr));
            
            select.innerHTML = uniqueOptions.map(option => {
                const textToShow = option.text;
                return `<option value="${option.value}">${textToShow}</option>`;
            }).join('');
            
            select.value = selectedValue;
            
            select.addEventListener('change', function() {
                const personIndex = parseInt(this.getAttribute('data-person-index'));
                const slotIndex = parseInt(this.getAttribute('data-slot-index'));
                const gameIndex = parseInt(this.getAttribute('data-game-index'));
                const selectedValue = this.value;

                // --- Lógica de validación de conflicto de mesa ---
                if (selectedValue !== '') {
                    let conflictFound = false;
                    peopleData.forEach((otherPerson, otherPersonIndex) => {
                        if (otherPersonIndex === personIndex) return; // Ignorar a la misma persona
                        
                        if (otherPerson.games[slotIndex] && otherPerson.games[slotIndex].includes(selectedValue)) {
                            conflictFound = true;
                        }
                    });

                    if (conflictFound) {
                        alert(`¡Advertencia! La mesa ${getGameTextByValue(selectedValue)} ya está asignada a otra persona en este turno.`);
                        
                        // Revertir la selección a su valor original
                        this.value = peopleData[personIndex].games[slotIndex][gameIndex] || '';
                        
                        // Evitar que se guarde el cambio
                        return;
                    }
                }
                // --- Fin de la lógica de validación ---
                
                let personGames = peopleData[personIndex].games;
                if (!personGames[slotIndex]) {
                    personGames[slotIndex] = [];
                }
                
                if (selectedValue === '') {
                     personGames[slotIdex].splice(gameIndex, 1);
                } else {
                    personGames[slotIndex][gameIndex] = selectedValue;
                }

                saveData();
                renderTable();
            });
            
            return select;
        }

        function handleMesaSelectionChange(selectElement) {
            saveData();
            renderTable();
        }

        function renderCustomGameList() {
            const customGameList = document.getElementById('custom-game-list');
            customGameList.innerHTML = '';
            
            const customGames = gameOptionsData.filter(option => !STATIC_GAME_OPTIONS.some(staticOpt => staticOpt.value === option.value));
            
            if (customGames.length > 0) {
                customGames.forEach(game => {
                    const listItem = document.createElement('li');
                    const repeatableText = game.repeatable ? ' (repetible)' : '';
                    listItem.textContent = `${game.text}${repeatableText}`;
                    
                    const deleteBtn = document.createElement('button');
                    deleteBtn.classList.add('remove-slot-btn');
                    deleteBtn.textContent = 'Eliminar';
                    deleteBtn.onclick = () => deleteCustomGame(game.value);
                    
                    listItem.appendChild(deleteBtn);
                    customGameList.appendChild(listItem);
                });
            } else {
                customGameList.innerHTML = '<li>No has añadido ningún juego personalizado.</li>';
            }
        }

        function deleteCustomGame(gameValue) {
            if (confirm(`¿Estás seguro de que quieres eliminar el juego "${getGameTextByValue(gameValue)}"?`)) {
                gameOptionsData = gameOptionsData.filter(option => option.value !== gameValue);
                
                peopleData.forEach(person => {
                    person.games.forEach(gamesArray => {
                        const index = gamesArray.indexOf(gameValue);
                        if (index > -1) {
                            gamesArray.splice(index, 1);
                        }
                    });
                });

                saveData();
                renderTable();
                renderCustomGameList();
            }
        }

        function updatePersonCount(leavingCount = 0) {
            const personCountElement = document.getElementById('person-count');
            let text = `Personas registradas: ${peopleData.length}`;
            if (leavingCount > 0) {
                text += ` (${leavingCount} proximas en irse)`;
            }
            personCountElement.textContent = text;
        }

        function addNameClickListeners(row) {
            const nameSpan = row.querySelector('.person-name');
            if (nameSpan) {
                nameSpan.addEventListener('click', function() {
                    const personIndex = parseInt(this.getAttribute('data-person-index'));
                    openPersonModal(personIndex);
                });
            }
        }

        function addSlot() {
            scheduleData.push({ start: '' });
            peopleData.forEach(person => person.games.push([]));
            saveData();
            renderTable();
        }

        function removeSlot() {
            if (scheduleData.length > 1) {
                scheduleData.pop();
                peopleData.forEach(person => person.games.pop());
                saveData();
                renderTable();
            } else {
                alert('No se puede eliminar la última columna.');
            }
        }
        
        function addDragAndDropEventListenersToSlots() {
            const slots = document.querySelectorAll('#schedule-header .draggable-slot');
            let draggedSlot = null;

            slots.forEach(slot => {
                slot.addEventListener('dragstart', function(e) {
                    draggedSlot = this;
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', this.getAttribute('data-slot-index'));
                    this.classList.add('dragging');
                });

                slot.addEventListener('dragend', function() {
                    this.classList.remove('dragging');
                    draggedSlot = null;
                });

                slot.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                });

                slot.addEventListener('drop', function(e) {
                    e.preventDefault();
                    if (draggedSlot && draggedSlot !== this) {
                        const fromIndex = parseInt(draggedSlot.getAttribute('data-slot-index'));
                        const toIndex = parseInt(this.getAttribute('data-slot-index'));
                        
                        const slotToMove = scheduleData.splice(fromIndex, 1)[0];
                        scheduleData.splice(toIndex, 0, slotToMove);

                        peopleData.forEach(person => {
                            const gameToMove = person.games.splice(fromIndex, 1)[0];
                            person.games.splice(toIndex, 0, gameToMove);
                        });

                        saveData();
                        renderTable();
                    }
                });
            });
        }

        function addDragAndDropEventListenersToPeople() {
            const peopleRows = document.querySelectorAll('#horario-body tr');
            let draggedPersonRow = null;
            
            peopleRows.forEach(row => {
                row.addEventListener('dragstart', function(e) {
                    draggedPersonRow = this;
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', this.getAttribute('data-person-index'));
                    this.classList.add('dragging');
                });

                row.addEventListener('dragend', function() {
                    this.classList.remove('dragging');
                    draggedPersonRow = null;
                });

                row.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                });

                row.addEventListener('drop', function(e) {
                    e.preventDefault();
                    if (draggedPersonRow && draggedPersonRow !== this) {
                        const fromIndex = parseInt(draggedPersonRow.getAttribute('data-person-index'));
                        const toIndex = parseInt(this.getAttribute('data-person-index'));

                        const personToMove = peopleData.splice(fromIndex, 1)[0];
                        peopleData.splice(toIndex, 0, personToMove);
                        
                        saveData();
                        renderTable();
                    }
                });
            });
        }
        
        document.getElementById('person-form').addEventListener('submit', function(event) {
            event.preventDefault();
            const nombre = document.getElementById('nombre').value;
            
            if (scheduleData.length === 0) {
                alert('La tabla debe tener al menos un horario para agregar personas.');
                return;
            }
            
            const newPerson = {
                name: nombre,
                games: Array.from({ length: scheduleData.length }, () => []),
                exitTime: '',
                color: ''
            };
            peopleData.push(newPerson);
            
            saveData();
            renderTable();
            
            document.getElementById('nombre').value = '';
        });

        document.getElementById('add-game-form').addEventListener('submit', function(event) {
            event.preventDefault();
            const newGameName = document.getElementById('new-game-name-input').value.trim();
            const isRepeatable = document.getElementById('repeatable-checkbox').checked;

            if (newGameName) {
                const newValue = newGameName.replace(/\s/g, ''); 
                if (!gameOptionsData.find(option => option.value === newValue)) {
                    gameOptionsData.push({ value: newValue, text: newGameName, repeatable: isRepeatable });
                    saveData();
                    renderTable();
                    renderCustomGameList();
                    document.getElementById('new-game-name-input').value = '';
                    document.getElementById('repeatable-checkbox').checked = false;
                } else {
                    alert('El nombre del juego ya existe.');
                }
            }
        });

        document.getElementById('clear-data').addEventListener('click', function() {
            if (confirm('¿Estás seguro de que quieres borrar todos los datos de la tabla? Esta acción no se puede deshacer.')) {
                localStorage.removeItem('appSchedule');
                localStorage.removeItem('appPeople');
                localStorage.removeItem('appGameOptions');
                window.location.reload(); 
            }
        });

        // --- Lógica del Modal de Persona ---
        const personModal = document.getElementById('personModal');
        const closePersonModalBtn = document.getElementById('closePersonModalBtn');
        const savePersonBtn = document.getElementById('savePersonBtn');
        const exitTimeInput = document.getElementById('exitTime');
        const personColorInput = document.getElementById('personColor');
        const deletePersonBtn = document.getElementById('deletePersonBtn');
        const replacesPersonSelect = document.getElementById('replacesPersonSelect');
        const replacePersonBtn = document.getElementById('replacePersonBtn');

        function openPersonModal(personIndex) {
            currentPersonIndex = personIndex;
            const person = peopleData[currentPersonIndex];

            document.getElementById('modalTitle').textContent = `Configurar a ${person.name}`;
            exitTimeInput.value = person.exitTime || '';
            personColorInput.value = person.color || '#ffffff';
            
            // Llenar el selector de reemplazo
            replacesPersonSelect.innerHTML = '<option value="">Seleccionar persona...</option>';
            peopleData.forEach((p, index) => {
                if (index !== currentPersonIndex) {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = p.name;
                    replacesPersonSelect.appendChild(option);
                }
            });
            
            personModal.style.display = 'block';
        }

        savePersonBtn.onclick = function() {
            if (currentPersonIndex !== -1) {
                peopleData[currentPersonIndex].exitTime = exitTimeInput.value;
                peopleData[currentPersonIndex].color = personColorInput.value;
                saveData();
                renderTable();
            }
            personModal.style.display = 'none';
        };

        closePersonModalBtn.onclick = function() {
            personModal.style.display = 'none';
        };

        window.onclick = function(event) {
            if (event.target == personModal) {
                personModal.style.display = 'none';
            }
            if (event.target == addGameModal) {
                addGameModal.style.display = 'none';
            }
        };

        deletePersonBtn.onclick = function() {
            if (confirm(`¿Estás seguro de que quieres eliminar a ${peopleData[currentPersonIndex].name}?`)) {
                peopleData.splice(currentPersonIndex, 1);
                saveData();
                personModal.style.display = 'none';
                renderTable();
            }
        };

        replacePersonBtn.onclick = function() {
            const replacedPersonIndex = replacesPersonSelect.value;
            if (replacedPersonIndex !== '' && currentPersonIndex !== -1) {
                const replacedPerson = peopleData[replacedPersonIndex];
                
                peopleData[currentPersonIndex].games = JSON.parse(JSON.stringify(replacedPerson.games));
                peopleData[currentPersonIndex].exitTime = replacedPerson.exitTime;

                if (confirm(`¿Estás seguro de que quieres reemplazar a "${replacedPerson.name}"? Los horarios de ${replacedPerson.name} se asignarán a ${peopleData[currentPersonIndex].name} y ${replacedPerson.name} será eliminado de la lista.`)) {
                    peopleData.splice(replacedPersonIndex, 1);
                    
                    if (parseInt(replacedPersonIndex) < currentPersonIndex) {
                        currentPersonIndex--;
                    }
                    
                    saveData();
                    personModal.style.display = 'none';
                    renderTable();
                }
            } else {
                alert('Por favor, selecciona una persona para reemplazar.');
            }
        };
        
        personColorInput.addEventListener('input', function() {
            if (currentPersonIndex !== -1) {
                const person = peopleData[currentPersonIndex];
                person.color = this.value;
                const modalTitle = document.getElementById('modalTitle');
                if (isDarkColor(person.color)) {
                    modalTitle.style.color = 'white';
                } else {
                    modalTitle.style.color = 'black';
                }
            }
        });
        
        // --- Lógica del Modal de Agregar Juego ---
        const addGameModal = document.getElementById('addGameModal');
        const addGameBtn = document.getElementById('add-game-btn');
        const closeAddGameModalBtn = document.getElementById('closeAddGameModalBtn');

        addGameBtn.onclick = function() {
            renderCustomGameList(); 
            addGameModal.style.display = 'block';
        };

        closeAddGameModalBtn.onclick = function() {
            addGameModal.style.display = 'none';
        };
        
        // --- Lógica del Modal de Alertas ---
        const warningModal = document.getElementById('warningModal');
        const alertsBtn = document.getElementById('alerts-btn');
        const closeWarningModalBtn = document.getElementById('closeWarningModalBtn');
        const warningList = document.getElementById('warning-list');

        alertsBtn.onclick = function() {
            warningModal.style.display = 'block';
        };

        closeWarningModalBtn.onclick = function() {
            warningModal.style.display = 'none';
        };

        warningList.addEventListener('click', function(event) {
            const clickedElement = event.target.closest('li');
            if (clickedElement) {
                const personIndex = clickedElement.getAttribute('data-person-index');
                warningModal.style.display = 'none';
                openPersonModal(personIndex);
            }
        });

        function checkExitTimes() {
            const now = new Date();
            const nowMinutes = now.getHours() * 60 + now.getMinutes();
            let peopleLeaving = [];

            peopleData.forEach((person, index) => {
                if (person.exitTime) {
                    const [exitHour, exitMinute] = person.exitTime.split(':').map(Number);
                    const exitMinutes = exitHour * 60 + exitMinute;
                    
                    const timeUntilExit = exitMinutes - nowMinutes;

                    if (timeUntilExit > 0 && timeUntilExit <= 20) {
                        peopleLeaving.push({ name: person.name, index: index });
                    }
                }
            });

            updatePersonCount(peopleLeaving.length);

            if (peopleLeaving.length > 0) {
                alertsBtn.classList.add('active');
                warningList.innerHTML = peopleLeaving.map(person => `<li data-person-index="${person.index}">⚠️ ${person.name}</li>`).join('');
                if (warningModal.style.display !== 'block' ) {
                   // No muestres el modal aquí, solo actualiza el botón de alerta
                }
            } else {
                alertsBtn.classList.remove('active');
                warningList.innerHTML = '<li>No hay alertas de salida en este momento.</li>';
                warningModal.style.display = 'none';
            }
        }

        function updateTableTimers() {
            const timeCells = document.querySelectorAll('#horario-body .time-in-table');
            const now = new Date();

            timeCells.forEach(cell => {
                const personIndex = parseInt(cell.getAttribute('data-person-index'));
                const person = peopleData[personIndex];

                let lastGameSlotIndex = -1;
                let lastGameValue = null;

                // 1. Encontrar el último turno (más reciente) en el que la persona tiene un juego asignado.
                for (let i = scheduleData.length - 1; i >= 0; i--) {
                    if (person.games[i] && person.games[i].length > 0 && person.games[i][0] !== '') {
                        lastGameSlotIndex = i;
                        lastGameValue = person.games[i][0];
                        break;
                    }
                }
                
                // Si no tiene ningún juego asignado, el temporizador es 0.
                if (lastGameSlotIndex === -1) {
                    cell.textContent = '00h 00m 00s';
                    return;
                }

                const lastGameSlot = scheduleData[lastGameSlotIndex];
                const [startHour, startMinute] = lastGameSlot.start.split(':').map(Number);
                const startTimeForTimer = new Date();
                startTimeForTimer.setHours(startHour, startMinute, 0, 0);

                let timerShouldRun = false;
                let nextGameStart = null;

                // 2. Buscar si el mismo juego está asignado a otra persona en un turno posterior.
                for (let i = lastGameSlotIndex + 1; i < scheduleData.length; i++) {
                    for (let otherPersonIndex = 0; otherPersonIndex < peopleData.length; otherPersonIndex++) {
                        if (otherPersonIndex === personIndex) continue; // Ignorar a la misma persona
                        
                        const otherPerson = peopleData[otherPersonIndex];
                        // Si otra persona tiene el mismo juego asignado en este turno, tomamos su hora de inicio.
                        if (otherPerson.games[i] && otherPerson.games[i].includes(lastGameValue)) {
                            nextGameStart = scheduleData[i].start;
                            break; // Encontramos el siguiente turno, no es necesario seguir buscando.
                        }
                    }
                    if (nextGameStart) break;
                }

                // 3. Determinar si el temporizador debe seguir corriendo.
                if (nextGameStart) {
                    const [nextHour, nextMinute] = nextGameStart.split(':').map(Number);
                    const nextGameDate = new Date();
                    nextGameDate.setHours(nextHour, nextMinute, 0, 0);
                    
                    // El temporizador se detiene solo si la hora actual es igual o posterior
                    // a la hora de inicio del próximo turno.
                    if (now < nextGameDate) {
                        timerShouldRun = true;
                    } else {
                        timerShouldRun = false;
                    }
                } else {
                    // Si no hay otro turno asignado, el temporizador debe seguir corriendo.
                    timerShouldRun = true;
                }

                // 4. Actualizar el contenido de la celda.
                if (timerShouldRun && startTimeForTimer <= now) {
                    const elapsedMilliseconds = now - startTimeForTimer;
                    
                    const elapsedSeconds = Math.floor(elapsedMilliseconds / 1000);
                    const hours = Math.floor((elapsedSeconds % (3600 * 24)) / 3600); // Horas en un día
                    const minutes = Math.floor((elapsedSeconds % 3600) / 60);
                    const seconds = elapsedSeconds % 60;
                    
                    const formattedTime = `${String(hours).padStart(2, '0')}h ${String(minutes).padStart(2, '0')}m ${String(seconds).padStart(2, '0')}s`;
                    cell.textContent = formattedTime;
                } else {
                    cell.textContent = '00h 00m 00s';
                }
            });
        }

        // --- Lógica del Reloj ---
        function updateClock() {
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            document.getElementById('current-time').textContent = `${hours}:${minutes}:${seconds}`;
        }

        // --- Lógica de la sección colapsable ---
        const registrationHeader = document.getElementById('registration-header');
        const registrationContent = document.getElementById('registration-content');

        registrationHeader.addEventListener('click', () => {
            registrationContent.classList.toggle('visible');
            registrationHeader.classList.toggle('expanded');
        });
        
        document.addEventListener('DOMContentLoaded', loadAllData);
    </script>
</body>
</html>
